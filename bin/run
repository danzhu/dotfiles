#!/bin/bash

usage() {
    echo "Usage: $0 [OPTION]... FILE [ARGS]"
    echo
    echo "  -h, --help      display this help and exit"
    echo "  -m, --mem       run with valgrind checking for memory errors"
}

OPTIONS=hm
LONG_OPTIONS=help,mem

OPT=$(getopt --options=$OPTIONS \
             --longoptions=$LONG_OPTIONS \
             --name "$0" \
             -- "$@")
if [[ $? -ne 0 ]]; then
    exit 2
fi

eval set -- "$OPT"

while true; do
    arg="$1"
    shift

    case "$arg" in
        -h|--help)
            usage
            exit
            ;;
        -m|--mem)
            MEM=true
            ;;
        --)
            break
            ;;
        *)
            echo "oops"
            exit 3
            ;;
    esac
done

if [[ $# -lt 1 ]]; then
    usage
    exit 2
fi

filename="$1"
shift
args=("$@")

execname="${filename%.*}"
execpath="$(readlink -f "$execname")"
cmd=("$execpath")

case "$filename" in
    *.s)
        gcc "$filename" -o "$execpath"
        ;;
    *.c)
        gcc -Wall -Wextra -g "$filename" -o "$execpath"
        ;;
    *.cc|*.cpp|*.C)
        g++ -std=c++17 -Wall -Wextra -g "$filename" -o "$execpath"
        ;;
    *.rs)
        rustc -g "$filename" -o "$execpath"
        ;;
    *.hs)
        stack ghc -- -g "$filename" -o "$execpath"
        ;;
    *.java)
        cmd=(java "$execname")
        javac -g "$filename"
        ;;
    *.py)
        cmd=(python "$filename")
        ;;
    *.rb)
        cmd=(ruby "$filename")
        ;;
    *)
        echo "extension not recognized" >&2
        exit 2
        ;;
esac

ret=$?
if [[ $ret -ne 0 ]]; then
    exit $ret
fi

if [[ $MEM = true ]]; then
    cmd=(valgrind --leak-check=full "${cmd[@]}")
fi

"${cmd[@]}" "${args[@]}"
