#!/bin/bash

if [ "$#" -lt 1 ] || [ "$#" -gt 2 ]; then
    echo "usage: $0 program [dir]"
    exit 2
fi

shopt -s nullglob

out=$(mktemp)
err=$(mktemp)
val=$(mktemp)

program="$(realpath $1)"
width="$(tput cols)"
cmd="timeout 20s valgrind --log-file=$val --error-exitcode=246 --leak-check=full"
diff="diff -y --width=$((width - 10))"
passed=0
failed=0

if [ -n "$2" ]; then
    cd "$2"
fi

list() {
    local f
    for f in *.in *.args; do
        echo "${f%.*}"
    done
}

pass() {
    tput setaf 2
    echo "[ PASSED ]"
    tput sgr0

    passed=$(($passed + 1))
}

fail() {
    tput setaf 1
    echo "[ $1 ]"
    tput sgr0

    failed=$(($failed + 1))
}

echo "  Testing $program..."
for tst in $(list | sort -u); do
    printf "    %-$((width - 16))s" "$(basename $tst)"

    if [ -r "$tst.args" ]; then
        args=$(cat $tst.args)
    else
        args=
    fi

    if [ -r "$tst.in" ]; then
        in="$tst.in"
    else
        in="/dev/null"
    fi

    { $cmd "$program" $args < "$in" > "$out" 2> "$err"; } 2> /dev/null
    ret=$?
    readarray lost < <(sed -nr 's/.*lost: ([0-9]+) bytes.*/\1/p' "$val")

    if [ $ret -eq 139 ]; then
        fail "SEG FT"
    elif [ $ret -eq 124 ]; then
        fail " TIME "
    elif [ -r "$tst.out" ] && ! dout=$($diff "$tst.out" "$out"); then
        fail "STDOUT"
        echo "$dout" | sed 's/^/\t/'
    elif [ -r "$tst.err" ] && ! derr=$($diff "$tst.err" "$err"); then
        fail "STDERR"
        echo "$derr" | sed 's/^/\t/'
    elif [ $ret -eq 246 ]; then
        fail "MEMORY"
        grep -o -E ' *[a-z]+ lost: [0-9]+ bytes in [0-9]+ blocks' "$val" | sed 's/^/    /'
    else
        pass
    fi
done

rm "$out"
rm "$err"
rm "$val"

echo "  Summary:"
echo "    $passed passed"
echo "    $failed failed"

if [ $failed -gt 0 ]; then
    exit 1
fi
