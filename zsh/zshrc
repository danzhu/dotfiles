autoload -Uz add-zsh-hook


# --- history ---
setopt appendhistory histignorealldups sharehistory

HISTFILE=~/.histfile
HISTSIZE=1000
SAVEHIST=1000


# --- completion ---
setopt extendedglob complete_in_word glob_complete

autoload -Uz compinit
compinit

zstyle ':completion:*' format 'Completing %d'
zstyle ':completion:*' glob 1
zstyle ':completion:*' group-name ''
zstyle ':completion:*' list-colors ''
zstyle ':completion:*' matcher-list '' 'm:{[:lower:]}={[:upper:]} r:|[._-]=* r:|=*' 'l:|=* r:|=*'
zstyle ':completion:*' rehash true
zstyle ':completion:*:cd:*' ignore-parents parent pwd
zstyle ':completion::*:(rm|vim):*' ignore-line true


# --- directory ---
setopt autocd autopushd pushdsilent


# --- help ---
autoload -Uz run-help
if (( $+aliases[run-help] )); then
    unalias run-help
fi
alias help='run-help'


# --- key bindings ---
setopt noflow_control

bindkey -v

bindkey -v '^P' up-history
bindkey -v '^N' down-history
bindkey -v '^?' backward-delete-char
bindkey -v '^H' backward-delete-char
bindkey -v '^W' backward-kill-word
bindkey -v '^R' history-incremental-search-backward
bindkey -v '^S' history-incremental-search-forward
bindkey -v '^A' beginning-of-line
bindkey -v '^E' end-of-line
bindkey -v '^Q' push-line-or-edit

function rationalise-dot() {
    if [[ $LBUFFER = (*[ /]|).. ]]; then
        LBUFFER+=/..
    else
        LBUFFER+=.
    fi
}
zle -N rationalise-dot
bindkey . rationalise-dot

bindkey ' ' magic-space

autoload -U edit-command-line
zle -N edit-command-line
bindkey -a '!' edit-command-line


# --- terminal title ---
function title() {
    emulate -L zsh
    setopt prompt_subst

    case "$TERM" in
        xterm*|rxvt*)
            print -nP "\e]2;$2:q\a" # window
            print -nP "\e]1;$1:q\a" # tab
            ;;
        screen*|tmux*)
            print -nP "\e]2;$2:q\a" # window
            print -nP "\ek$1:q\e\\" # tab
            ;;
        *)
            if [[ -n "$terminfo[fs1]" && -n "$terminfo[ts1]" ]]; then
                echoti ts1
                print -nP "$1"
                echoti fs1
            fi
            ;;
    esac
}

function title-precmd() {
    title 'zsh' '%m: %~'
}

function title-preexec() {
    local cmd="${1[(wr)^(*=*|sudo|ssh|-*)]:gs/%/%%}"
    local line="${2:gs/%/%%}"
    title '$cmd' '%m: $line'
}

add-zsh-hook precmd title-precmd
add-zsh-hook preexec title-preexec


# --- shell prompt ---
setopt noprompt_sp

function prompt-grab() {
    echo "$1" | sed -nE "s/^$2\$/\\1/p"
}

function prompt-diverge() {
    local count="$(prompt-grab "$1" "$2")"
    if [[ $count -ne 0 ]]; then
        print -nP " $3$count%f"
    fi
}

function prompt-count() {
    local count
    if count="$(echo "$1" | grep -cE "$2")"; then
        print -nP " $3$count%f"
    fi
}

function prompt-precmd() {
    local code=$?

    emulate -L zsh
    setopt glob_subst

    print ''

    # exit code
    if [[ $code -ne 0 ]]; then
        print -P "%1F%K %k %B$code%b%f"
    fi

    # host
    print -nP '%B%K'
    if [[ $UID -eq 0 ]]; then
        # root
        print -nP ' %1F%m%f'
    elif [[ -n "$SSH_CONNECTION" ]]; then
        # ssh
        print -nP ' %m'
    fi
    print -nP ' %k '

    # path
    local dir olddir
    local i=1
    while dir="$(print -P "%-$i~")" && [[ "$dir" != "$olddir" ]]; do
        if [[ ! -r $dir ]]; then
            # non-readable
            print -nP '%1F'
        elif [[ ! -w $dir ]]; then
            # non-writable
            print -nP '%3F'
        elif [[ -L $dir ]]; then
            # symlink
            print -nP '%6F'
        else
            # regular
            print -nP '%4F'
        fi

        # print segment
        print -nP "${dir[${#olddir} + 1,${#dir}]}%f"

        i=$((i + 1))
        olddir="$dir"
    done

    # git prompt
    local gs
    if gs="$(git status --porcelain=v2 --branch --untracked-files=all \
            2> /dev/null)"; then
        local branch="$(prompt-grab "$gs" '# branch\.head (.*)')"

        print -nP ' %K '

        if [[ "$branch" = '(detached)' ]]; then
            # detached head
            branch="$(git rev-parse --short HEAD)"
            print -nP '%3F'
        elif [[ -f "$(git rev-parse --git-dir)/MERGE_HEAD" ]]; then
            # merging
            print -nP '%1F'
        elif echo "$gs" | grep -qE '^# branch\.upstream .*$'; then
            # has upstream
            print -nP '%5F'
        else
            # local branch
            print -nP '%2F'
        fi

        print -nP "$branch%f"

        local tag
        if tag="$(git describe --tags --exact-match 2> /dev/null)"; then
            print -nP " #$tag"
        fi

        # ahead
        prompt-diverge "$gs" '# branch\.ab \+(.*) -.*' '%2FA'
        # behind
        prompt-diverge "$gs" '# branch\.ab \+.* -(.*)' '%3FB'

        print -nP ' %k'

        # added
        prompt-count "$gs" '^[12] [MADRCU].' '%2F+'
        # changed
        prompt-count "$gs" '^[12] .[MADRCU]' '%3F~'
        # unmerged
        prompt-count "$gs" '^u' '%1F!'
        # untracked
        prompt-count "$gs" '^\?' '%4F?'

        # stashes
        local stash="$(git stash list | wc -l)"
        if [[ $stash -ne 0 ]]; then
            print -nP " %5F&$stash%f"
        fi
    fi

    print -P '%b'
}

add-zsh-hook precmd prompt-precmd

PS1='%K %k '
PS2='%K%7F+%f%k '


# --- common ---
source ~/.dotfiles/common/aliases
source ~/.dotfiles/common/functions


# --- suffix aliases ---
alias -s c=$EDITOR
alias -s cc=$EDITOR
alias -s css=$EDITOR
alias -s h=$EDITOR
alias -s js=$EDITOR
alias -s md=$EDITOR
alias -s txt=$EDITOR
alias -s vim=$EDITOR


# --- freeze tty ---
ttyctl -f


# --- syntax highlighting ---
HL=/usr/share/zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
if [[ -f "$HL" ]]; then
    ZSH_HIGHLIGHT_HIGHLIGHTERS=(main brackets)
    source "$HL"
fi
unset HL
